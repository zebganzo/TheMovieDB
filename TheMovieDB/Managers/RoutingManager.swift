//
//  RoutingManager.swift
//  TheMovieDB
//
//  Created by Sebastiano Catellani on 16.09.18.
//  Copyright Â© 2018 Sebastiano Catellani. All rights reserved.
//

import ReactiveSwift
import Result

/// Events triggered that the routing component is in charge of handling.
enum RoutingEvent {

    /// Entry point of the routing.
    case entryPoint

    /// An action consists of an output (Any) generated by the view model of a screen.
    case action(ScreenViewModel, Any)
}

/// Base Protocol of routing.
protocol RoutingManagerProtocol {

    /// Given a routing event (view model + its output),
    /// it returns the a `ScreenViewModel` (next view model to show).
    func route(with event: RoutingEvent) -> ScreenViewModel?
}

/// Base protocol for the viewModel handled by the routing component.
protocol RouterViewModelProtocol { }

class RoutingManager {
    let searchClient: SearchProtocol
    let suggestionsClient: SuggestionsProtocol
    let imageClient: ImageProtocol

    init(searchClient: SearchProtocol,
         suggestionsProtocol: SuggestionsProtocol,
         imageClient: ImageProtocol) {
        self.searchClient = searchClient
        self.suggestionsClient = suggestionsProtocol
        self.imageClient = imageClient
    }
}

extension RoutingManager: RoutingManagerProtocol {
    func route(with event: RoutingEvent) -> ScreenViewModel? {
        switch event {

        // The current entry point is the movie search screen.
        case .entryPoint:
            let movieSearchViewModel = MovieSearchViewModel(searchClient: self.searchClient, suggestionsProtocol: self.suggestionsClient)
            return .movieSearch(movieSearchViewModel)

        // In case of output from a view model, it needs to decide based on these two information.
        case .action(let routerViewModel, let output):

            switch routerViewModel {
            case .movieSearch:
                // From the search movie view(model) is possible to show only
                // the movies list showing the search results
                guard let (query, searchResult) = output as? (String, SearchResult<Movie>) else {
                    assertionFailure("The output type has to match the (String, SearchResult<Movie>) instead of \(type(of: output))")
                    return nil
                }
                let moviesListViewModel = MoviesListViewModel(searchClient: self.searchClient,
                                                              imageClient: self.imageClient,
                                                              searchResult: searchResult,
                                                              queryName: query)
                return .moviesList(moviesListViewModel)

            case .moviesList:
                // From the movies list is not possible to go any further
                assertionFailure("This case is currenctly not possible")
                return nil
            }
        }
    }
}
